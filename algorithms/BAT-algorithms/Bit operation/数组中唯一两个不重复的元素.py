"""
一、题目
    给定的任意数组只有两个数字只出现了一次，其他数字出现了偶数次，
    求只出现一次的两个数？

二、思路
    * 暴力求解
        使用hash统计每个数字出现的次数。时间复杂度O(N),空间复杂度是O(N)
    * 位运算快速求解
        利用异或运算的性质可以快速求解，见知识点介绍
        性质1: “利用 x ^ x = 0  和 x ^ 0 = x 的特点，可以将三个数中重复的两个数去除，只留下另一个数”
        性质2: “n&(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于n二进制表示 10110 100 ，-n 得到 01001100，相与&得到 00000100”
    * 具体想法：
        将所有数字进行异或操作得到 diff ，其实 diff 就是两个只出现一次的数字的异或结果。出现次数为偶数的数字，异或的结果都是0。
        接下来 就如何利用 diff 找到这两个数字？
        两个不同的数进行异或，二进制数 diff 中一定包含 1。
        那么我们可以利用上面的性质2 找到diff中最右边的一个1，其余的全是0的数 loc。（假如diff = 10110 100 ,那么 loc = diff &(-diff) = 00000100），
            而且，这 1 一定来自于要求的两个数在二进制中对应位置上异或的结果，
        再次遍历数组，利用将数组里的每一个数和loc求与&运算，结果是否为0，将数组分成两个子数组【子数组的特点是：只有一个数字出现1次，其余的都出现偶数次】
        那么，此时的问题就和“数组中唯一一个不重复的元素”一模一样了。
三、例子
    2 2 3 3 4
    2^2=0
        0^3=3
            3^3=0
                0^4=4
    连续异或操作后即可得到只出现一次的数字
"""


def single_numbers(nums):
    diff = 0
    res = [0, 0]
    for num in nums:
        diff = diff ^ num
    loc = diff & (-diff)
    for num in nums:
        if num & loc == 0:
            res[0] = res[0] ^ num
        else:
            res[1] = res[1] ^ num
    return res


if __name__ == '__main__':
    nums = [1, 2, 1, 3, 2, 3, 5, 4, 4, 4, 4, 6]
    print(single_numbers(nums))
